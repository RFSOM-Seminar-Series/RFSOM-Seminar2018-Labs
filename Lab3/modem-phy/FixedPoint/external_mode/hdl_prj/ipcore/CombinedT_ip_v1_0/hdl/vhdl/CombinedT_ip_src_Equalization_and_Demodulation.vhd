-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\combinedTxRx_ExternalMode\CombinedT_ip_src_Equalization_and_Demodulation.vhd
-- Created: 2018-02-01 13:20:09
-- 
-- Generated by MATLAB 9.3 and HDL Coder 3.11
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: CombinedT_ip_src_Equalization_and_Demodulation
-- Source Path: combinedTxRx_ExternalMode/Combined TX and RX/Receiver HDL/Frame Recover/Equalization and Demodulation
-- Hierarchy Level: 3
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY CombinedT_ip_src_Equalization_and_Demodulation IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        Trigger                           :   IN    std_logic;
        Data_re                           :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        Data_im                           :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        EQmu                              :   IN    std_logic_vector(15 DOWNTO 0);  -- int16
        Enable                            :   IN    std_logic;
        AfterEQ_re                        :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        AfterEQ_im                        :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        validOut                          :   OUT   std_logic;
        resetViterbi                      :   OUT   std_logic;
        crcEnd                            :   OUT   std_logic;
        dataOut                           :   OUT   std_logic_vector(0 TO 1);  -- boolean [2]
        packLen                           :   OUT   std_logic_vector(15 DOWNTO 0);  -- uint16
        HeaderDebug_status                :   OUT   std_logic_vector(7 DOWNTO 0);  -- uint8
        HeaderDebug_s1                    :   OUT   std_logic_vector(31 DOWNTO 0);  -- uint32
        HeaderDebug_s2                    :   OUT   std_logic_vector(31 DOWNTO 0)  -- uint32
        );
END CombinedT_ip_src_Equalization_and_Demodulation;


ARCHITECTURE rtl OF CombinedT_ip_src_Equalization_and_Demodulation IS

  -- Component Declarations
  COMPONENT CombinedT_ip_src_DFE_block
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          Trigger                         :   IN    std_logic;
          data_re                         :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          data_im                         :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          EQmu                            :   IN    std_logic_vector(15 DOWNTO 0);  -- int16
          Enable_out4                     :   IN    std_logic;
          dataEQed_re                     :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          dataEQed_im                     :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          start                           :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT CombinedT_ip_src_QPSK_Demodulator_Baseband
    PORT( in0_re                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          in0_im                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          out0                            :   OUT   std_logic_vector(0 TO 1)  -- boolean [2]
          );
  END COMPONENT;

  COMPONENT CombinedT_ip_src_Header_Controller
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          headerStart                     :   IN    std_logic;
          data                            :   IN    std_logic_vector(0 TO 1);  -- boolean [2]
          enableDownstream                :   OUT   std_logic;
          packetLenBitsOut                :   OUT   std_logic_vector(15 DOWNTO 0);  -- uint16
          resetViterbi                    :   OUT   std_logic;
          crcStart                        :   OUT   std_logic;
          status                          :   OUT   std_logic_vector(7 DOWNTO 0);  -- uint8
          s1                              :   OUT   std_logic_vector(31 DOWNTO 0);  -- uint32
          s2                              :   OUT   std_logic_vector(31 DOWNTO 0)  -- uint32
          );
  END COMPONENT;

  COMPONENT CombinedT_ip_src_2_Bit_Descrambler
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          u1                              :   IN    std_logic_vector(0 TO 1);  -- boolean [2]
          reset_1                         :   IN    std_logic;
          Enable_out4                     :   IN    std_logic;
          y1                              :   OUT   std_logic_vector(0 TO 1)  -- boolean [2]
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : CombinedT_ip_src_DFE_block
    USE ENTITY work.CombinedT_ip_src_DFE_block(rtl);

  FOR ALL : CombinedT_ip_src_QPSK_Demodulator_Baseband
    USE ENTITY work.CombinedT_ip_src_QPSK_Demodulator_Baseband(rtl);

  FOR ALL : CombinedT_ip_src_Header_Controller
    USE ENTITY work.CombinedT_ip_src_Header_Controller(rtl);

  FOR ALL : CombinedT_ip_src_2_Bit_Descrambler
    USE ENTITY work.CombinedT_ip_src_2_Bit_Descrambler(rtl);

  -- Signals
  SIGNAL Enable_out4                      : std_logic;
  SIGNAL DFE_out1_re                      : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL DFE_out1_im                      : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL DFE_out2                         : std_logic;
  SIGNAL Enable_out4_1                    : std_logic;
  SIGNAL enb_gated                        : std_logic;
  SIGNAL enb_gated_1                      : std_logic;
  SIGNAL Skip_EQ_Training_Symbols_After_Barker_reg : std_logic_vector(0 TO 249);  -- ufix1 [250]
  SIGNAL Skip_EQ_Training_Symbols_After_Barker_out1 : std_logic;
  SIGNAL Skip_EQ_Training_Symbols_After_Barker_out1_1 : std_logic;
  SIGNAL enb_gated_2                      : std_logic;
  SIGNAL QPSK_Demodulator_Baseband_out1   : std_logic_vector(0 TO 1);  -- boolean [2]
  SIGNAL QPSK_Demodulator_Baseband_out1_1 : std_logic_vector(0 TO 1);  -- boolean [2]
  SIGNAL QPSK_Demodulator_Baseband_out1_last_value : std_logic_vector(0 TO 1);  -- boolean [2]
  SIGNAL enableDownstream                 : std_logic;
  SIGNAL packetLenBitsOut                 : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL resetViterbi_1                   : std_logic;
  SIGNAL crcStart                         : std_logic;
  SIGNAL status                           : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL s1                               : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL s2                               : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL enableDownstream_1               : std_logic;
  SIGNAL enableDownstream_last_value      : std_logic;
  SIGNAL enb_gated_3                      : std_logic;
  SIGNAL resetViterbi_2                   : std_logic;
  SIGNAL resetViterbi_last_value          : std_logic;
  SIGNAL Align_with_Start_out1            : std_logic;
  SIGNAL Align_with_Start_out1_1          : std_logic;
  SIGNAL Align_with_Start_out1_last_value : std_logic;
  SIGNAL crcStart_1                       : std_logic;
  SIGNAL crcStart_last_value              : std_logic;
  SIGNAL alpha2_Bit_Descrambler_out1      : std_logic_vector(0 TO 1);  -- boolean [2]
  SIGNAL packetLenBitsOut_unsigned        : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL packetLenBitsOut_1               : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL packetLenBitsOut_last_value      : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL status_unsigned                  : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL status_1                         : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL status_last_value                : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL s1_unsigned                      : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL s1_1                             : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL s1_last_value                    : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL s2_unsigned                      : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL s2_1                             : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL s2_last_value                    : unsigned(31 DOWNTO 0);  -- uint32

BEGIN
  -- Header is an uncoded 16 sequence and all bits are duplicated for checking
  -- 
  -- Once header is found and decoded, controller will manage packet length and field aspects,
  -- including CRC check control and viterbi/scramber resets

  u_DFE : CombinedT_ip_src_DFE_block
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              Trigger => Trigger,
              data_re => Data_re,  -- sfix16_En14
              data_im => Data_im,  -- sfix16_En14
              EQmu => EQmu,  -- int16
              Enable_out4 => Enable_out4,
              dataEQed_re => DFE_out1_re,  -- sfix16_En14
              dataEQed_im => DFE_out1_im,  -- sfix16_En14
              start => DFE_out2
              );

  u_QPSK_Demodulator_Baseband : CombinedT_ip_src_QPSK_Demodulator_Baseband
    PORT MAP( in0_re => DFE_out1_re,  -- sfix16_En14
              in0_im => DFE_out1_im,  -- sfix16_En14
              out0 => QPSK_Demodulator_Baseband_out1  -- boolean [2]
              );

  u_Header_Controller : CombinedT_ip_src_Header_Controller
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb_gated,
              headerStart => Skip_EQ_Training_Symbols_After_Barker_out1_1,
              data => QPSK_Demodulator_Baseband_out1_1,  -- boolean [2]
              enableDownstream => enableDownstream,
              packetLenBitsOut => packetLenBitsOut,  -- uint16
              resetViterbi => resetViterbi_1,
              crcStart => crcStart,
              status => status,  -- uint8
              s1 => s1,  -- uint32
              s2 => s2  -- uint32
              );

  u_2_Bit_Descrambler : CombinedT_ip_src_2_Bit_Descrambler
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              u1 => QPSK_Demodulator_Baseband_out1_1,  -- boolean [2]
              reset_1 => Align_with_Start_out1_1,
              Enable_out4 => Enable_out4,
              y1 => alpha2_Bit_Descrambler_out1  -- boolean [2]
              );

  Enable_out4 <= Enable;

  reduced_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Enable_out4_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Enable_out4_1 <= Enable_out4;
      END IF;
    END IF;
  END PROCESS reduced_process;


  enb_gated <= Enable_out4_1 AND enb;

  enb_gated_1 <= Enable_out4 AND enb;

  Skip_EQ_Training_Symbols_After_Barker_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Skip_EQ_Training_Symbols_After_Barker_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_1 = '1' THEN
        Skip_EQ_Training_Symbols_After_Barker_reg(0) <= DFE_out2;
        Skip_EQ_Training_Symbols_After_Barker_reg(1 TO 249) <= Skip_EQ_Training_Symbols_After_Barker_reg(0 TO 248);
      END IF;
    END IF;
  END PROCESS Skip_EQ_Training_Symbols_After_Barker_process;

  Skip_EQ_Training_Symbols_After_Barker_out1 <= Skip_EQ_Training_Symbols_After_Barker_reg(249);

  delayMatch1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Skip_EQ_Training_Symbols_After_Barker_out1_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Skip_EQ_Training_Symbols_After_Barker_out1_1 <= Skip_EQ_Training_Symbols_After_Barker_out1;
      END IF;
    END IF;
  END PROCESS delayMatch1_process;


  enb_gated_2 <= Enable_out4_1 AND enb;

  out0_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      QPSK_Demodulator_Baseband_out1_last_value <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_2 = '1' THEN
        QPSK_Demodulator_Baseband_out1_last_value <= QPSK_Demodulator_Baseband_out1_1;
      END IF;
    END IF;
  END PROCESS out0_bypass_process;


  
  QPSK_Demodulator_Baseband_out1_1 <= QPSK_Demodulator_Baseband_out1_last_value WHEN Enable_out4_1 = '0' ELSE
      QPSK_Demodulator_Baseband_out1;

  out0_bypass_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      enableDownstream_last_value <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated = '1' THEN
        enableDownstream_last_value <= enableDownstream_1;
      END IF;
    END IF;
  END PROCESS out0_bypass_1_process;


  
  enableDownstream_1 <= enableDownstream_last_value WHEN Enable_out4_1 = '0' ELSE
      enableDownstream;

  enb_gated_3 <= Enable_out4_1 AND enb;

  out2_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      resetViterbi_last_value <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated = '1' THEN
        resetViterbi_last_value <= resetViterbi_2;
      END IF;
    END IF;
  END PROCESS out2_bypass_process;


  
  resetViterbi_2 <= resetViterbi_last_value WHEN Enable_out4_1 = '0' ELSE
      resetViterbi_1;

  Align_with_Start_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Align_with_Start_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_3 = '1' THEN
        Align_with_Start_out1 <= resetViterbi_2;
      END IF;
    END IF;
  END PROCESS Align_with_Start_process;


  out0_bypass_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Align_with_Start_out1_last_value <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_3 = '1' THEN
        Align_with_Start_out1_last_value <= Align_with_Start_out1_1;
      END IF;
    END IF;
  END PROCESS out0_bypass_2_process;


  
  Align_with_Start_out1_1 <= Align_with_Start_out1_last_value WHEN Enable_out4_1 = '0' ELSE
      Align_with_Start_out1;

  out3_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      crcStart_last_value <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated = '1' THEN
        crcStart_last_value <= crcStart_1;
      END IF;
    END IF;
  END PROCESS out3_bypass_process;


  
  crcStart_1 <= crcStart_last_value WHEN Enable_out4_1 = '0' ELSE
      crcStart;

  packetLenBitsOut_unsigned <= unsigned(packetLenBitsOut);

  out1_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      packetLenBitsOut_last_value <= to_unsigned(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated = '1' THEN
        packetLenBitsOut_last_value <= packetLenBitsOut_1;
      END IF;
    END IF;
  END PROCESS out1_bypass_process;


  
  packetLenBitsOut_1 <= packetLenBitsOut_last_value WHEN Enable_out4_1 = '0' ELSE
      packetLenBitsOut_unsigned;

  packLen <= std_logic_vector(packetLenBitsOut_1);

  status_unsigned <= unsigned(status);

  out4_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      status_last_value <= to_unsigned(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated = '1' THEN
        status_last_value <= status_1;
      END IF;
    END IF;
  END PROCESS out4_bypass_process;


  
  status_1 <= status_last_value WHEN Enable_out4_1 = '0' ELSE
      status_unsigned;

  HeaderDebug_status <= std_logic_vector(status_1);

  s1_unsigned <= unsigned(s1);

  out5_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      s1_last_value <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated = '1' THEN
        s1_last_value <= s1_1;
      END IF;
    END IF;
  END PROCESS out5_bypass_process;


  
  s1_1 <= s1_last_value WHEN Enable_out4_1 = '0' ELSE
      s1_unsigned;

  HeaderDebug_s1 <= std_logic_vector(s1_1);

  s2_unsigned <= unsigned(s2);

  out6_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      s2_last_value <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated = '1' THEN
        s2_last_value <= s2_1;
      END IF;
    END IF;
  END PROCESS out6_bypass_process;


  
  s2_1 <= s2_last_value WHEN Enable_out4_1 = '0' ELSE
      s2_unsigned;

  HeaderDebug_s2 <= std_logic_vector(s2_1);


  AfterEQ_re <= DFE_out1_re;

  AfterEQ_im <= DFE_out1_im;

  validOut <= enableDownstream_1;

  resetViterbi <= Align_with_Start_out1_1;

  crcEnd <= crcStart_1;

  dataOut <= alpha2_Bit_Descrambler_out1;

END rtl;

