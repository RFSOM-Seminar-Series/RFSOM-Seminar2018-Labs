-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\combinedTxRx_ExternalMode\CombinedT_ip_src_CRCCompare.vhd
-- Created: 2018-02-01 13:20:08
-- 
-- Generated by MATLAB 9.3 and HDL Coder 3.11
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: CombinedT_ip_src_CRCCompare
-- Source Path: combinedTxRx_ExternalMode/Combined TX and RX/Receiver HDL/CRC Check and DMA Pack/CRC Check ES/General 
-- CRC Syndrom Detector HDL Optimized/CRCCompar
-- Hierarchy Level: 5
-- 
-- Checksum Comparison
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY CombinedT_ip_src_CRCCompare IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        dataRef                           :   IN    std_logic;  -- ufix1
        endIn                             :   IN    std_logic;  -- ufix1
        dataOutgen                        :   IN    std_logic;  -- ufix1
        startOutgen                       :   IN    std_logic;  -- ufix1
        endOutgen                         :   IN    std_logic;  -- ufix1
        validOutgen                       :   IN    std_logic;  -- ufix1
        outputCRC                         :   IN    std_logic;  -- ufix1
        dataOut                           :   OUT   std_logic;  -- ufix1
        startOut                          :   OUT   std_logic;  -- ufix1
        endOut                            :   OUT   std_logic;  -- ufix1
        validOut                          :   OUT   std_logic;  -- ufix1
        err                               :   OUT   std_logic;  -- ufix1
        bufferenb                         :   OUT   std_logic  -- ufix1
        );
END CombinedT_ip_src_CRCCompare;


ARCHITECTURE rtl OF CombinedT_ip_src_CRCCompare IS

  -- Signals
  SIGNAL outputCRC_1                      : std_logic;  -- ufix1
  SIGNAL const0data                       : std_logic;  -- ufix1
  SIGNAL tdataout                         : std_logic;  -- ufix1
  SIGNAL dataout_delay_register_reg       : std_logic_vector(0 TO 31);  -- ufix1 [32]
  SIGNAL startout_delay_register_reg      : std_logic_vector(0 TO 31);  -- ufix1 [32]
  SIGNAL const0ctl                        : std_logic;  -- ufix1
  SIGNAL tvalidout                        : std_logic;  -- ufix1
  SIGNAL validout_delay_register_reg      : std_logic_vector(0 TO 31);  -- ufix1 [32]
  SIGNAL cnt1rst                          : std_logic;  -- ufix1
  SIGNAL cnt2enb                          : std_logic;  -- ufix1
  SIGNAL cnt2out                          : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL cnt1out                          : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL bufferenb_1                      : std_logic;  -- ufix1
  SIGNAL alpha_reg                        : std_logic_vector(0 TO 31);  -- ufix1 [32]
  SIGNAL checksumreg                      : std_logic;  -- ufix1
  SIGNAL relop_relop1                     : std_logic;
  SIGNAL cmpresult                        : std_logic;  -- ufix1
  SIGNAL const0cnt                        : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL numerr                           : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL totalerr                         : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL dtotalerr                        : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL adder_add_cast                   : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL adder_add_temp                   : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL hadErr                           : std_logic;  -- ufix1

BEGIN
  -- Buffer Checksum output control signal
  outputCRC_register_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      outputCRC_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        outputCRC_1 <= outputCRC;
      END IF;
    END IF;
  END PROCESS outputCRC_register_process;


  -- Constant 0
  const0data <= '0';

  -- Data output
  
  tdataout <= dataOutgen WHEN outputCRC_1 = '0' ELSE
      const0data;

  dataout_delay_register_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      dataout_delay_register_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        dataout_delay_register_reg(0) <= tdataout;
        dataout_delay_register_reg(1 TO 31) <= dataout_delay_register_reg(0 TO 30);
      END IF;
    END IF;
  END PROCESS dataout_delay_register_process;

  dataOut <= dataout_delay_register_reg(31);

  -- startOut
  startout_delay_register_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      startout_delay_register_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        startout_delay_register_reg(0) <= startOutgen;
        startout_delay_register_reg(1 TO 31) <= startout_delay_register_reg(0 TO 30);
      END IF;
    END IF;
  END PROCESS startout_delay_register_process;

  startOut <= startout_delay_register_reg(31);

  -- endOut
  endOut <= endOutgen;

  const0ctl <= '0';

  -- validOut
  
  tvalidout <= validOutgen WHEN outputCRC_1 = '0' ELSE
      const0ctl;

  validout_delay_register_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      validout_delay_register_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        validout_delay_register_reg(0) <= tvalidout;
        validout_delay_register_reg(1 TO 31) <= validout_delay_register_reg(0 TO 30);
      END IF;
    END IF;
  END PROCESS validout_delay_register_process;

  validOut <= validout_delay_register_reg(31);

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 31
  counter_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      cnt2out <= to_unsigned(16#00#, 5);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF cnt1rst = '1' THEN 
          cnt2out <= to_unsigned(16#00#, 5);
        ELSIF cnt2enb = '1' THEN 
          cnt2out <= cnt2out + to_unsigned(16#01#, 5);
        END IF;
      END IF;
    END IF;
  END PROCESS counter_process;


  
  cnt1rst <= '1' WHEN cnt2out = to_unsigned(16#1F#, 5) ELSE
      '0';

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 31
  counter_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      cnt1out <= to_unsigned(16#00#, 5);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF cnt1rst = '1' THEN 
          cnt1out <= to_unsigned(16#00#, 5);
        ELSIF endIn = '1' THEN 
          cnt1out <= cnt1out + to_unsigned(16#01#, 5);
        END IF;
      END IF;
    END IF;
  END PROCESS counter_1_process;


  -- Generate Checksum buffer enable
  
  cnt2enb <= '1' WHEN cnt1out >= to_unsigned(16#01#, 5) ELSE
      '0';

  bufferenb_1 <= cnt2enb OR outputCRC_1;

  -- Buffer input Checksum
  c_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      alpha_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND bufferenb_1 = '1' THEN
        alpha_reg(0) <= dataRef;
        alpha_reg(1 TO 31) <= alpha_reg(0 TO 30);
      END IF;
    END IF;
  END PROCESS c_2_process;

  checksumreg <= alpha_reg(31);

  -- Compare Checksum
  
  relop_relop1 <= '1' WHEN dataOutgen /= checksumreg ELSE
      '0';

  
  cmpresult <= const0ctl WHEN outputCRC_1 = '0' ELSE
      relop_relop1;

  const0cnt <= to_unsigned(16#00#, 5);

  
  totalerr <= numerr WHEN endOutgen = '0' ELSE
      const0cnt;

  totalErr_register_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      dtotalerr <= to_unsigned(16#00#, 5);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        dtotalerr <= totalerr;
      END IF;
    END IF;
  END PROCESS totalErr_register_process;


  -- Count number of errors
  adder_add_cast <= '0' & '0' & '0' & '0' & '0' & cmpresult;
  adder_add_temp <= adder_add_cast + resize(dtotalerr, 6);
  
  numerr <= "11111" WHEN adder_add_temp(5) /= '0' ELSE
      adder_add_temp(4 DOWNTO 0);

  -- Detectot error
  
  hadErr <= '1' WHEN numerr > to_unsigned(16#00#, 5) ELSE
      '0';

  
  err <= const0ctl WHEN endOutgen = '0' ELSE
      hadErr;

  bufferenb <= bufferenb_1;

END rtl;

