-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\combinedTxRx_ExternalMode\CombinedT_ip_src_DMA_Control.vhd
-- Created: 2018-02-01 13:20:10
-- 
-- Generated by MATLAB 9.3 and HDL Coder 3.11
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: CombinedT_ip_src_DMA_Control
-- Source Path: combinedTxRx_ExternalMode/Combined TX and RX/Transmitter HDL/DMA Interface/DMA Control
-- Hierarchy Level: 3
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY CombinedT_ip_src_DMA_Control IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb_1_4_0                         :   IN    std_logic;
        byteIn                            :   IN    std_logic_vector(63 DOWNTO 0);  -- ufix64
        validIn                           :   IN    std_logic;
        EOF                               :   IN    std_logic;
        bitOut                            :   OUT   std_logic;
        validOut                          :   OUT   std_logic;
        startOut                          :   OUT   std_logic;
        payloadLength                     :   OUT   std_logic_vector(15 DOWNTO 0);  -- uint16
        readyForInput                     :   OUT   std_logic
        );
END CombinedT_ip_src_DMA_Control;


ARCHITECTURE rtl OF CombinedT_ip_src_DMA_Control IS

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL byteIn_unsigned                  : unsigned(63 DOWNTO 0);  -- ufix64
  SIGNAL payloadLength_tmp                : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL wordBuffer                       : unsigned(63 DOWNTO 0);  -- ufix64
  SIGNAL bitCounter                       : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL payloadLenBuff                   : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL mode                             : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL inputByteCounter                 : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL wordBuffer_next                  : unsigned(63 DOWNTO 0);  -- ufix64
  SIGNAL bitCounter_next                  : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL payloadLenBuff_next              : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL mode_next                        : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL inputByteCounter_next            : unsigned(15 DOWNTO 0);  -- uint16

BEGIN
  byteIn_unsigned <= unsigned(byteIn);

  RxTxFixedPointLibrary_c18_DMA_Control_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      wordBuffer <= to_unsigned(0, 64);
      bitCounter <= to_unsigned(16#00#, 8);
      payloadLenBuff <= to_unsigned(16#0000#, 16);
      mode <= to_unsigned(16#00#, 8);
      inputByteCounter <= to_unsigned(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        wordBuffer <= wordBuffer_next;
        bitCounter <= bitCounter_next;
        payloadLenBuff <= payloadLenBuff_next;
        mode <= mode_next;
        inputByteCounter <= inputByteCounter_next;
      END IF;
    END IF;
  END PROCESS RxTxFixedPointLibrary_c18_DMA_Control_process;

  RxTxFixedPointLibrary_c18_DMA_Control_output : PROCESS (byteIn_unsigned, validIn, EOF, wordBuffer, bitCounter, payloadLenBuff, mode,
       inputByteCounter)
    VARIABLE c : std_logic;
    VARIABLE bit_idx : unsigned(7 DOWNTO 0);
    VARIABLE add_temp : unsigned(8 DOWNTO 0);
    VARIABLE add_temp_0 : unsigned(16 DOWNTO 0);
  BEGIN
    c := '0';
    wordBuffer_next <= wordBuffer;
    bitCounter_next <= bitCounter;
    payloadLenBuff_next <= payloadLenBuff;
    mode_next <= mode;
    inputByteCounter_next <= inputByteCounter;
    -- This block converts the byte input pipeline into bits and extract the
    -- length the packet into its own signal
    -- Payload length setup
    -- Capture first payload length byte(s)
    IF (validIn AND hdlcoder_to_stdlogic(mode = to_unsigned(16#00000000#, 8))) = '1' THEN 
      mode_next <= to_unsigned(16#02#, 8);
      IF byteIn_unsigned(63 DOWNTO 16) /= X"000000000000" THEN 
        payloadLenBuff_next <= X"FFFF";
      ELSE 
        payloadLenBuff_next <= byteIn_unsigned(15 DOWNTO 0);
      END IF;
      -- Set outputs
      bitOut <= '0';
      validOut <= '0';
      startOut <= '1';
      payloadLength_tmp <= to_unsigned(16#0000#, 16);
      readyForInput <= '1';
      -- Reset counters
      inputByteCounter_next <= to_unsigned(16#0008#, 16);
      -- Reset
      bitCounter_next <= to_unsigned(16#01#, 8);
      -- Reset
      -- Payload output
    ELSIF (bitCounter > to_unsigned(16#00000000#, 8)) AND (mode = to_unsigned(16#00000002#, 8)) THEN 
      -- Set outputs
      IF bitCounter = to_unsigned(16#00000001#, 8) THEN 
        IF byteIn_unsigned(0) > '0' THEN 
          bitOut <= '1';
        ELSE 
          bitOut <= '0';
        END IF;
        wordBuffer_next <= byteIn_unsigned;
        -- Save byte
      ELSE 
        IF (bitCounter >= to_unsigned(16#00000001#, 8)) AND (bitCounter <= to_unsigned(16#00000040#, 8)) THEN 
          bit_idx := bitCounter - 1;
          c := wordBuffer(to_integer(bit_idx));
        END IF;
        IF c > '0' THEN 
          bitOut <= '1';
        ELSE 
          bitOut <= '0';
        END IF;
      END IF;
      startOut <= '0';
      payloadLength_tmp <= payloadLenBuff;
      validOut <= '1';
      -- Set flag to DMA and next mode
      IF bitCounter >= to_unsigned(16#00000040#, 8) THEN 
        bitCounter_next <= to_unsigned(16#01#, 8);
        -- Reset
        -- If we've processed all the bytes we need to wait for downstream
        -- to be done
        IF inputByteCounter < payloadLenBuff THEN 
          readyForInput <= '1';
          -- Tell them we need next byte
          -- Bytes processed
          add_temp_0 := resize(inputByteCounter, 17) + to_unsigned(16#00008#, 17);
          IF add_temp_0(16) /= '0' THEN 
            inputByteCounter_next <= X"FFFF";
          ELSE 
            inputByteCounter_next <= add_temp_0(15 DOWNTO 0);
          END IF;
        ELSE 
          readyForInput <= '0';
          -- Hold DMA off for now, next call will go to EOF
          mode_next <= to_unsigned(16#03#, 8);
        END IF;
      ELSE 
        add_temp := resize(bitCounter, 9) + to_unsigned(16#001#, 9);
        IF add_temp(8) /= '0' THEN 
          bitCounter_next <= "11111111";
        ELSE 
          bitCounter_next <= add_temp(7 DOWNTO 0);
        END IF;
        readyForInput <= '0';
      END IF;
      -- Waiting for EOF from packet generation
    ELSIF mode = to_unsigned(16#00000003#, 8) THEN 
      bitOut <= '0';
      validOut <= '1';
      -- Keep downstream processing going
      startOut <= '0';
      payloadLength_tmp <= payloadLenBuff;
      IF EOF = '1' THEN 
        -- Done with frame now ask for more data
        readyForInput <= '1';
        mode_next <= to_unsigned(16#00#, 8);
        -- Reset
      ELSE 
        readyForInput <= '0';
      END IF;
    ELSE 
      -- not-valid and need another byte
      bitOut <= '0';
      IF mode = to_unsigned(16#00000000#, 8) THEN 
        validOut <= '1';
        -- Let LFSR Run
      ELSE 
        validOut <= '0';
      END IF;
      startOut <= '0';
      payloadLength_tmp <= to_unsigned(16#0000#, 16);
      readyForInput <= '1';
    END IF;
  END PROCESS RxTxFixedPointLibrary_c18_DMA_Control_output;


  payloadLength <= std_logic_vector(payloadLength_tmp);

END rtl;

