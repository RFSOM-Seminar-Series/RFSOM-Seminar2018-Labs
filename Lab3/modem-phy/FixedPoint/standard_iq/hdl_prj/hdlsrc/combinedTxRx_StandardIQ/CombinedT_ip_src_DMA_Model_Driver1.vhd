-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\combinedTxRx_StandardIQ\CombinedT_ip_src_DMA_Model_Driver1.vhd
-- Created: 2018-02-01 11:49:53
-- 
-- Generated by MATLAB 9.3 and HDL Coder 3.11
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: CombinedT_ip_src_DMA_Model_Driver1
-- Source Path: combinedTxRx_StandardIQ/Combined TX and RX/DMA Model Driver1
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.CombinedT_ip_src_Combined_TX_and_RX_pkg.ALL;

ENTITY CombinedT_ip_src_DMA_Model_Driver1 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb_1_4_0                         :   IN    std_logic;
        driver                            :   IN    std_logic;
        enable                            :   IN    std_logic;
        payload                           :   OUT   std_logic_vector(63 DOWNTO 0);  -- ufix64
        valid                             :   OUT   std_logic
        );
END CombinedT_ip_src_DMA_Model_Driver1;


ARCHITECTURE rtl OF CombinedT_ip_src_DMA_Model_Driver1 IS

  -- Constants
  CONSTANT nc                             : vector_of_unsigned64(0 TO 12) := 
    (to_unsigned(72, 64), to_unsigned(101, 64), to_unsigned(108, 64), to_unsigned(108, 64), to_unsigned(111, 64),
     to_unsigned(32, 64), to_unsigned(87, 64), to_unsigned(111, 64), to_unsigned(114, 64), to_unsigned(108, 64),
     to_unsigned(100, 64), to_unsigned(32, 64), to_unsigned(48, 64));  -- ufix64 [13]

  -- Signals
  SIGNAL payload_tmp                      : unsigned(63 DOWNTO 0);  -- ufix64
  SIGNAL indx                             : unsigned(63 DOWNTO 0);  -- ufix64
  SIGNAL indx_not_empty                   : std_logic;
  SIGNAL mode                             : signed(7 DOWNTO 0);  -- int8
  SIGNAL pSize                            : unsigned(63 DOWNTO 0);  -- ufix64
  SIGNAL counter                          : unsigned(63 DOWNTO 0);  -- ufix64
  SIGNAL msg                              : vector_of_unsigned64(0 TO 12);  -- ufix64 [13]
  SIGNAL payloadIndx                      : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL indx_next                        : unsigned(63 DOWNTO 0);  -- ufix64
  SIGNAL indx_not_empty_next              : std_logic;
  SIGNAL mode_next                        : signed(7 DOWNTO 0);  -- int8
  SIGNAL pSize_next                       : unsigned(63 DOWNTO 0);  -- ufix64
  SIGNAL counter_next                     : unsigned(63 DOWNTO 0);  -- ufix64
  SIGNAL msg_next                         : vector_of_unsigned64(0 TO 12);  -- ufix64 [13]
  SIGNAL payloadIndx_next                 : unsigned(7 DOWNTO 0);  -- uint8

BEGIN
  DMA_Model_Driver1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      indx_not_empty <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        indx <= indx_next;
        indx_not_empty <= indx_not_empty_next;
        mode <= mode_next;
        pSize <= pSize_next;
        counter <= counter_next;
        msg <= msg_next;
        payloadIndx <= payloadIndx_next;
      END IF;
    END IF;
  END PROCESS DMA_Model_Driver1_process;

  DMA_Model_Driver1_output : PROCESS (driver, enable, indx, indx_not_empty, mode, pSize, counter, msg, payloadIndx)
    VARIABLE indx_temp : unsigned(63 DOWNTO 0);
    VARIABLE mode_temp : signed(7 DOWNTO 0);
    VARIABLE pSize_temp : unsigned(63 DOWNTO 0);
    VARIABLE counter_temp : unsigned(63 DOWNTO 0);
    VARIABLE msg_temp : vector_of_unsigned64(0 TO 12);
    VARIABLE payloadIndx_temp : unsigned(7 DOWNTO 0);
    VARIABLE add_temp : unsigned(65 DOWNTO 0);
    VARIABLE add_temp_0 : unsigned(8 DOWNTO 0);
    VARIABLE sub_cast : signed(31 DOWNTO 0);
    VARIABLE add_temp_1 : unsigned(65 DOWNTO 0);
    VARIABLE add_temp_2 : unsigned(65 DOWNTO 0);
  BEGIN
    indx_temp := indx;
    mode_temp := mode;
    pSize_temp := pSize;
    counter_temp := counter;
    msg_temp := msg;
    payloadIndx_temp := payloadIndx;
    indx_not_empty_next <= indx_not_empty;
    -- each char will be mapped to a 64 bit word
    IF ( NOT indx_not_empty) = '1' THEN 
      msg_temp := nc;
      pSize_temp := to_unsigned(1600, 64);
      -- Bytes in message (must be multiple of 64 bits)
      --pSize = fi(8*15,0,64,0); % Bytes in message (must be multiple of 64 bits)
      indx_temp := to_unsigned(1600, 64);
      indx_not_empty_next <= '1';
      mode_temp := to_signed(16#00#, 8);
      counter_temp := to_unsigned(0, 64);
      payloadIndx_temp := to_unsigned(16#00#, 8);
    END IF;
    -- Make default MSG
    -- Constant
    -- Output MSG
    IF (enable AND driver) = '1' THEN 
      CASE mode_temp IS
        WHEN "00000000" =>
          -- Fresh packet start
          payload_tmp <= pSize_temp;
          --Upper bits
          mode_temp := to_signed(16#01#, 8);
          payloadIndx_temp := to_unsigned(16#00#, 8);
          indx_temp := to_unsigned(0, 64);
          valid <= '1';
          --fprintf('(TX) Sending new packet with length: %u\n',uint64(pSize));
          -- Update packet count
          add_temp_1 := resize(counter_temp, 66) + to_unsigned(48, 66);
          IF add_temp_1(65 DOWNTO 64) /= "00" THEN 
            msg_temp(12) := X"FFFFFFFFFFFFFFFF";
          ELSE 
            msg_temp(12) := add_temp_1(63 DOWNTO 0);
          END IF;
        WHEN OTHERS => 
          add_temp := resize(indx_temp, 66) + to_unsigned(8, 66);
          IF add_temp(65 DOWNTO 64) /= "00" THEN 
            indx_temp := X"FFFFFFFFFFFFFFFF";
          ELSE 
            indx_temp := add_temp(63 DOWNTO 0);
          END IF;
          valid <= '1';
          IF indx_temp <= to_unsigned(104, 64) THEN 
            -- Send message characters
            add_temp_0 := resize(payloadIndx_temp, 9) + to_unsigned(16#001#, 9);
            IF add_temp_0(8) /= '0' THEN 
              payloadIndx_temp := "11111111";
            ELSE 
              payloadIndx_temp := add_temp_0(7 DOWNTO 0);
            END IF;
            sub_cast := signed(resize(payloadIndx_temp, 32));
            payload_tmp <= msg_temp(to_integer(sub_cast - 1));
          ELSIF indx_temp < pSize_temp THEN 
            -- Send padded data
            payload_tmp <= unsigned'(X"AAAAAAAAAAAAAAAA");
            -- Alternating ones and zeros %sum(2.^[0:2:63]));
          ELSE 
            -- reached end of frame
            mode_temp := to_signed(16#00#, 8);
            payloadIndx_temp := to_unsigned(16#00#, 8);
            payload_tmp <= to_unsigned(0, 64);
            -- Update message counter
            IF counter_temp >= to_unsigned(9, 64) THEN 
              counter_temp := to_unsigned(0, 64);
            ELSE 
              add_temp_2 := resize(counter_temp, 66) + to_unsigned(1, 66);
              IF add_temp_2(65 DOWNTO 64) /= "00" THEN 
                counter_temp := X"FFFFFFFFFFFFFFFF";
              ELSE 
                counter_temp := add_temp_2(63 DOWNTO 0);
              END IF;
            END IF;
          END IF;
      END CASE;
    ELSE 
      valid <= '0';
      payload_tmp <= to_unsigned(0, 64);
    END IF;
    indx_next <= indx_temp;
    mode_next <= mode_temp;
    pSize_next <= pSize_temp;
    counter_next <= counter_temp;
    msg_next <= msg_temp;
    payloadIndx_next <= payloadIndx_temp;
  END PROCESS DMA_Model_Driver1_output;


  payload <= std_logic_vector(payload_tmp);

END rtl;

