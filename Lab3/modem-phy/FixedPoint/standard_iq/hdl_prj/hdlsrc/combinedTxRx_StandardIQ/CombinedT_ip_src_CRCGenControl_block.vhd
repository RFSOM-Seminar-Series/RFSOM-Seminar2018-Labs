-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\combinedTxRx_StandardIQ\CombinedT_ip_src_CRCGenControl_block.vhd
-- Created: 2018-02-01 11:49:53
-- 
-- Generated by MATLAB 9.3 and HDL Coder 3.11
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: CombinedT_ip_src_CRCGenControl_block
-- Source Path: combinedTxRx_StandardIQ/Combined TX and RX/Transmitter HDL/Packet Generation/Payload/General CRC 
-- Generator HDL Optimized/CRCGenContro
-- Hierarchy Level: 5
-- 
-- CRC Generator Control Signals Generation
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY CombinedT_ip_src_CRCGenControl_block IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb_1_4_0                         :   IN    std_logic;
        startIn                           :   IN    std_logic;  -- ufix1
        endIn                             :   IN    std_logic;  -- ufix1
        validIn                           :   IN    std_logic;  -- ufix1
        startOut                          :   OUT   std_logic;  -- ufix1
        processMsg                        :   OUT   std_logic;  -- ufix1
        padZero                           :   OUT   std_logic;  -- ufix1
        outputCRC                         :   OUT   std_logic;  -- ufix1
        endOut                            :   OUT   std_logic;  -- ufix1
        validOut                          :   OUT   std_logic;  -- ufix1
        counter                           :   OUT   std_logic_vector(4 DOWNTO 0);  -- ufix5
        counter_outputCRC                 :   OUT   std_logic_vector(4 DOWNTO 0)  -- ufix5
        );
END CombinedT_ip_src_CRCGenControl_block;


ARCHITECTURE rtl OF CombinedT_ip_src_CRCGenControl_block IS

  -- Signals
  SIGNAL deofin                           : std_logic;  -- ufix1
  SIGNAL cnt3out                          : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL processzero_short                : std_logic;  -- ufix1
  SIGNAL cnt3enb                          : std_logic;  -- ufix1
  SIGNAL tsysenb_short                    : std_logic;  -- ufix1
  SIGNAL tprocessMsg                      : std_logic;  -- ufix1
  SIGNAL sysenb_short                     : std_logic;  -- ufix1
  SIGNAL ready                            : std_logic;  -- ufix1
  SIGNAL cnt1enb                          : std_logic;  -- ufix1
  SIGNAL cnt2out                          : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL cnt2rst                          : std_logic;  -- ufix1
  SIGNAL cnt2enb                          : std_logic;  -- ufix1
  SIGNAL compare_cmpOut                   : std_logic;
  SIGNAL cnt2fstout                       : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL cnt2fstout_is_not0               : std_logic;
  SIGNAL cnt1rst                          : std_logic;  -- ufix1
  SIGNAL cnt1out                          : std_logic;  -- ufix1
  SIGNAL dtprocessMsg                     : std_logic;  -- ufix1
  SIGNAL rdtprocessMsg                    : std_logic;  -- ufix1
  SIGNAL startout_1                       : std_logic;  -- ufix1
  SIGNAL sof_delay_register_reg           : std_logic_vector(0 TO 31);  -- ufix1 [32]
  SIGNAL processzero                      : std_logic;  -- ufix1
  SIGNAL tpadZero                         : std_logic;  -- ufix1
  SIGNAL cnt4rst                          : std_logic;  -- ufix1
  SIGNAL cnt5enb                          : std_logic;  -- ufix1
  SIGNAL cnt5out                          : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL cnt4out                          : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL dteofout                         : std_logic;  -- ufix1
  SIGNAL rdteofout                        : std_logic;  -- ufix1
  SIGNAL sysenb                           : std_logic;  -- ufix1
  SIGNAL udvalidin                        : std_logic;  -- ufix1
  SIGNAL rcnt3enb                         : std_logic;  -- ufix1
  SIGNAL clearvalidin                     : std_logic;  -- ufix1
  SIGNAL tvalidout                        : std_logic;  -- ufix1
  SIGNAL tvalidout_delay_register_reg     : std_logic_vector(0 TO 31);  -- ufix1 [32]
  SIGNAL dvalidout                        : std_logic;  -- ufix1

BEGIN
  eofin_delay_register_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      deofin <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        deofin <= endIn;
      END IF;
    END IF;
  END PROCESS eofin_delay_register_process;


  
  processzero_short <= '1' WHEN cnt3out < to_unsigned(16#1F#, 5) ELSE
      '0';

  tsysenb_short <= cnt3enb AND processzero_short;

  sysenb_short <= tprocessMsg OR tsysenb_short;

  ready <=  NOT sysenb_short;

  cnt1enb <= ready AND startIn;

  -- Counter 3 enable signal
  
  cnt3enb <= '1' WHEN cnt2out >= to_unsigned(16#01#, 5) ELSE
      '0';

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 31
  -- 
  -- Counter3: counts when start to pad zeros
  counter_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      cnt3out <= to_unsigned(16#00#, 5);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        IF cnt2rst = '1' THEN 
          cnt3out <= to_unsigned(16#00#, 5);
        ELSIF cnt3enb = '1' THEN 
          cnt3out <= cnt3out + to_unsigned(16#01#, 5);
        END IF;
      END IF;
    END IF;
  END PROCESS counter_1_process;


  
  cnt2rst <= '1' WHEN cnt3out = to_unsigned(16#1F#, 5) ELSE
      '0';

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 31
  --  count to value  = 1
  -- 
  -- Counter2: triggered by End of frame signal
  counter_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      cnt2out <= to_unsigned(16#00#, 5);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        IF cnt2rst = '1' THEN 
          cnt2out <= to_unsigned(16#00#, 5);
        ELSIF cnt2enb = '1' THEN 
          IF cnt2out = to_unsigned(16#01#, 5) THEN 
            cnt2out <= to_unsigned(16#00#, 5);
          ELSE 
            cnt2out <= cnt2out + to_unsigned(16#1F#, 5);
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS counter_2_process;


  
  compare_cmpOut <= '1' WHEN cnt2out = to_unsigned(16#00#, 5) ELSE
      '0';

  cnt2fstout <= '0' & '0' & '0' & '0' & compare_cmpOut;

  
  cnt2fstout_is_not0 <= '1' WHEN cnt2fstout /= to_unsigned(16#00#, 5) ELSE
      '0';

  -- Counter 2 enable signal
  cnt2enb <= tprocessMsg AND deofin;

  cnt1rst <= cnt2enb AND cnt2fstout_is_not0;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  -- 
  -- Counter1: triggered by Start of frame signal
  counter_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      cnt1out <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        IF cnt1rst = '1' THEN 
          cnt1out <= '0';
        ELSIF cnt1enb = '1' THEN 
          cnt1out <=  NOT cnt1out;
        END IF;
      END IF;
    END IF;
  END PROCESS counter_3_process;


  
  tprocessMsg <= '1' WHEN cnt1out = '1' ELSE
      '0';

  tprocessMsg_delay_register_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      dtprocessMsg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        dtprocessMsg <= tprocessMsg;
      END IF;
    END IF;
  END PROCESS tprocessMsg_delay_register_process;


  rdtprocessMsg <=  NOT dtprocessMsg;

  startout_1 <= tprocessMsg AND rdtprocessMsg;

  -- Start of frame output signal
  sof_delay_register_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      sof_delay_register_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        sof_delay_register_reg(0) <= startout_1;
        sof_delay_register_reg(1 TO 31) <= sof_delay_register_reg(0 TO 30);
      END IF;
    END IF;
  END PROCESS sof_delay_register_process;

  startOut <= sof_delay_register_reg(31);

  -- processMsg
  processMsg <= tprocessMsg;

  processzero <= '1';

  tpadZero <= cnt3enb AND processzero;

  -- padZero
  padZero <= tpadZero;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 31
  -- 
  -- Counter5: counts when start to output CRC
  counter_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      cnt5out <= to_unsigned(16#00#, 5);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        IF cnt4rst = '1' THEN 
          cnt5out <= to_unsigned(16#00#, 5);
        ELSIF cnt5enb = '1' THEN 
          cnt5out <= cnt5out + to_unsigned(16#01#, 5);
        END IF;
      END IF;
    END IF;
  END PROCESS counter_4_process;


  
  cnt4rst <= '1' WHEN cnt5out = to_unsigned(16#1F#, 5) ELSE
      '0';

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 31
  -- 
  -- Counter4: triggered after processing all the padded zeros
  counter_5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      cnt4out <= to_unsigned(16#00#, 5);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        IF cnt4rst = '1' THEN 
          cnt4out <= to_unsigned(16#00#, 5);
        ELSIF cnt2rst = '1' THEN 
          cnt4out <= cnt4out + to_unsigned(16#01#, 5);
        END IF;
      END IF;
    END IF;
  END PROCESS counter_5_process;


  -- Counter 5 enable signal
  
  cnt5enb <= '1' WHEN cnt4out >= to_unsigned(16#01#, 5) ELSE
      '0';

  -- outputCRC
  outputCRC <= cnt5enb;

  eofout_delay_register_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      dteofout <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        dteofout <= cnt4rst;
      END IF;
    END IF;
  END PROCESS eofout_delay_register_process;


  rdteofout <=  NOT dteofout;

  -- End of frame output signal
  endOut <= cnt4rst AND rdteofout;

  sysenb <= tprocessMsg OR tpadZero;

  validin_unitdelay_register_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      udvalidin <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        udvalidin <= validIn;
      END IF;
    END IF;
  END PROCESS validin_unitdelay_register_process;


  rcnt3enb <=  NOT cnt3enb;

  
  clearvalidin <= udvalidin WHEN cnt3enb = '0' ELSE
      rcnt3enb;

  tvalidout <= sysenb AND clearvalidin;

  -- Buffer the validIn signal
  tvalidout_delay_register_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tvalidout_delay_register_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        tvalidout_delay_register_reg(0) <= tvalidout;
        tvalidout_delay_register_reg(1 TO 31) <= tvalidout_delay_register_reg(0 TO 30);
      END IF;
    END IF;
  END PROCESS tvalidout_delay_register_process;

  dvalidout <= tvalidout_delay_register_reg(31);

  -- Data valid output
  validOut <= dvalidout OR cnt5enb;

  counter <= std_logic_vector(cnt3out);

  counter_outputCRC <= std_logic_vector(cnt5out);

END rtl;

