-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\combinedTxRx_AXIMM\CombinedT_ip_src_2_Bit_Descrambler.vhd
-- Created: 2018-02-01 18:12:05
-- 
-- Generated by MATLAB 9.3 and HDL Coder 3.11
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: CombinedT_ip_src_2_Bit_Descrambler
-- Source Path: combinedTxRx_AXIMM/Combined TX and RX/Receiver HDL/Frame Recover/Equalization and Demodulation/2 
-- Bit Descramble
-- Hierarchy Level: 4
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY CombinedT_ip_src_2_Bit_Descrambler IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        u1                                :   IN    std_logic_vector(0 TO 1);  -- boolean [2]
        reset_1                           :   IN    std_logic;
        Enable_out4                       :   IN    std_logic;
        y1                                :   OUT   std_logic_vector(0 TO 1)  -- boolean [2]
        );
END CombinedT_ip_src_2_Bit_Descrambler;


ARCHITECTURE rtl OF CombinedT_ip_src_2_Bit_Descrambler IS

  -- Component Declarations
  COMPONENT CombinedT_ip_src_MATLAB_Function
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          bits                            :   IN    std_logic_vector(0 TO 1);  -- boolean [2]
          reset_1                         :   IN    std_logic;
          bufferA                         :   OUT   std_logic_vector(0 TO 6);  -- boolean [7]
          bufferB                         :   OUT   std_logic_vector(0 TO 6)  -- boolean [7]
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : CombinedT_ip_src_MATLAB_Function
    USE ENTITY work.CombinedT_ip_src_MATLAB_Function(rtl);

  -- Signals
  SIGNAL delayMatch_reg                   : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL Enable_out4_1                    : std_logic;
  SIGNAL enb_gated                        : std_logic;
  SIGNAL bufferA                          : std_logic_vector(0 TO 6);  -- boolean [7]
  SIGNAL bufferB                          : std_logic_vector(0 TO 6);  -- boolean [7]
  SIGNAL bufferA_1                        : std_logic_vector(0 TO 6);  -- boolean [7]
  SIGNAL bufferA_last_value               : std_logic_vector(0 TO 6);  -- boolean [7]
  SIGNAL bufferA_0                        : std_logic;
  SIGNAL bufferA_2                        : std_logic;
  SIGNAL bufferA_4                        : std_logic;
  SIGNAL bufferA_6                        : std_logic;
  SIGNAL state_xor1_out1                  : std_logic;
  SIGNAL bufferB_1                        : std_logic_vector(0 TO 6);  -- boolean [7]
  SIGNAL bufferB_last_value               : std_logic_vector(0 TO 6);  -- boolean [7]
  SIGNAL bufferB_0                        : std_logic;
  SIGNAL bufferB_2                        : std_logic;
  SIGNAL bufferB_4                        : std_logic;
  SIGNAL u1_0                             : std_logic;
  SIGNAL input_xor1_out1                  : std_logic;
  SIGNAL bufferB_6                        : std_logic;
  SIGNAL state_xor2_out1                  : std_logic;
  SIGNAL data_in                          : std_logic;
  SIGNAL input_xor2_out1                  : std_logic;
  SIGNAL Mux_out1                         : std_logic_vector(0 TO 1);  -- boolean [2]

BEGIN
  -- This is a special Descrambler which can process 2 bits at a time

  u_MATLAB_Function : CombinedT_ip_src_MATLAB_Function
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb_gated,
              bits => u1,  -- boolean [2]
              reset_1 => reset_1,
              bufferA => bufferA,  -- boolean [7]
              bufferB => bufferB  -- boolean [7]
              );

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayMatch_reg(0) <= Enable_out4;
        delayMatch_reg(1) <= delayMatch_reg(0);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  Enable_out4_1 <= delayMatch_reg(1);

  enb_gated <= Enable_out4_1 AND enb;

  out0_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      bufferA_last_value <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated = '1' THEN
        bufferA_last_value <= bufferA_1;
      END IF;
    END IF;
  END PROCESS out0_bypass_process;


  
  bufferA_1 <= bufferA_last_value WHEN Enable_out4_1 = '0' ELSE
      bufferA;

  bufferA_0 <= bufferA_1(0);

  bufferA_2 <= bufferA_1(2);

  bufferA_4 <= bufferA_1(4);

  bufferA_6 <= bufferA_1(6);

  state_xor1_out1 <= bufferA_6 XOR (bufferA_4 XOR (bufferA_0 XOR bufferA_2));

  out1_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      bufferB_last_value <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated = '1' THEN
        bufferB_last_value <= bufferB_1;
      END IF;
    END IF;
  END PROCESS out1_bypass_process;


  
  bufferB_1 <= bufferB_last_value WHEN Enable_out4_1 = '0' ELSE
      bufferB;

  bufferB_0 <= bufferB_1(0);

  bufferB_2 <= bufferB_1(2);

  bufferB_4 <= bufferB_1(4);

  u1_0 <= u1(0);

  input_xor1_out1 <= state_xor1_out1 XOR u1_0;

  bufferB_6 <= bufferB_1(6);

  state_xor2_out1 <= bufferB_6 XOR (bufferB_4 XOR (bufferB_0 XOR bufferB_2));

  data_in <= u1(1);

  input_xor2_out1 <= state_xor2_out1 XOR data_in;

  Mux_out1(0) <= input_xor1_out1;
  Mux_out1(1) <= input_xor2_out1;

  y1 <= Mux_out1;

END rtl;

